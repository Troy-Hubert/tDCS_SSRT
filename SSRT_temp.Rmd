---
title: "SSRT"
output: html_document
date: "2023-07-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
#install.packages("splithalfr")

library(splithalfr)
```

## Dataset
Load the included SST dataset and inspect its documentation.

```{r}


??splithalfr
data("ds_sst", package = "splithalfr")
??ds_sst
ds_sst

??splithalfr
#look at the data
ds_sst[1:10,]
```

Drop the first trial
```{r}
ds_sst <- ds_sst[ds_sst$trial > 1, ]

ds_1 <- subset(ds_sst, participant  == 1)

ds_1 <- ds_1 |>
  mutate(
    ssd = ssd*.001,
    rt = rt*.001
  )
table(ds_1$condition)
```

## Scoring the SRT
```{r}
fn_score <- function(ds) { 
  # Mean SSD
  mean_ssd <- mean(ds[ds$condition == 1, ]$ssd)
  # Proportion of failed nogos
  p_failed_nogo <- 1 - mean(ds[ds$condition == 1, ]$response)
  # Go RTs
  go_rts <- ds[
    ds$condition == 0 &
      ds$rt > 0,
    ]$rt
  # n-th percentile of Go RTs
  rt_quantile <- quantile(go_rts, p_failed_nogo, names = FALSE)
  # SSRTi
  return(rt_quantile - mean_ssd)
}
```

Scoring a particiapnt 
```{r}
fn_score(subset(ds_1))
```

Scoring everyone
```{r}
scores <- by(
  ds_sst,
  ds_sst$participant,
  fn_score
)
SSRT_DF<- data.frame(
      participant = names(scores),
      score = as.vector(scores)
)

SSRT_DF[1:10,]
```


```{r}
install.packages("SSRTcalc")

library(SSRTcalc)
data(adaptive)

data("adaptive", package = "SSRTcalc")

# new_id = ID
# soa = SSD (ignore for go trials)
# vol = stop(1) or go (0) trials
#coh = percent coherent dots in teh kinematogram go task
# RT_ex responds time in seconds
# did the participant respond go trials trials/omitresponsein"stop"trials(1)ornot(0)?

view(adaptive1)

adaptive1 <- adaptive |>
  filter(new_id == 1)

sum(is.na(adaptive1$correct))

integration_adaptiveSSD(
    adaptive1,
    stop_col='vol', 
    ssd_col='soa',
    rt_col='RT_exp',
    acc_col='correct')
integration_adaptiveSSD(
    ds_sst_1,
    stop_col='condition',          
    ssd_col='ssd',
    rt_col='rt',
    acc_col='response')

# SSRT Formula ->    
sapply(split(df,df$ID),integration_adaptiveSSD,stop_col='STOP_COL',          ssd_col='SSD_COL',rt_col='RT_COL',acc_col='CORRECT')

integration_adaptiveSSD(adaptive1,stop_col='vol', ssd_col='soa',rt_col='RT_exp',acc_col='correct')


sapply(split(adaptive,adaptive$new_id),integration_adaptiveSSD,stop_col='vol', ssd_col='soa',rt_col='RT_exp',acc_col='correct')


#' Estimating SSRT using integration method for studies that use adaptive (increasing/decreasing by a given increment) stop-signal delays.
#' @export
#' @param df  Dataframe with response time, accuracy, indication whether trial is stop or go, and delays for a given trial.
#' @param stop_col Name of the column in the dataframe \code{df} that indicates whether a given trial is a "stop" or a "go" trial ( 0 = go, 1 = stop)
#' @param rt_col Name of the column in the dataframe \code{df} that contains response time in seconds
#' @param acc_col Name of the column in the dataframe \code{df} that contains accuracy of inhibition ( 0 = incorrect, 1 = correct)
#' @param ssd_col Name of the column in the dataframe \code{df} that contains stop-signal delays
#' @return SSRT corresponding to the \code{ nth rt - ssd; n = p(respond|signal)*number of goRTs}
#' @examples
#' data(adaptive)
#' sapply(split(adaptive, adaptive$new_id), integration_adaptiveSSD, stop_col = 'vol',
#' ssd_col = 'soa', rt_col = 'RT_exp', acc_col = 'correct')





# Integration_adaptiveSSD
# The integration method assumes that the finishing time of the stop process
# corresponds to the nth RT,
# with n equal to the number of RTs in the RT distribution
# multiplied by the overall p(respond|signal)
# (Logan, 1981); SSRT can then be estimated by subtracting the mean
# SSD from the nth RT
# (taken from Verbruggen 2013)



integration_adaptiveSSD <- function(df, stop_col, rt_col, acc_col, ssd_col) {
  go_trials = df[ which(df[,stop_col] == 0),]
  stop_trials <- df[ which(df[,stop_col]==1), ]
  stop_count <- sum(stop_trials[,acc_col])
  overall_prob = 1 - stop_count/nrow(stop_trials)
  df1 <- go_trials[order(go_trials[,rt_col], na.last = NA) , ]
  nrt <- length(df1[,rt_col])
  nthindex = as.integer(round(nrt*overall_prob))
  meanssd = mean(stop_trials[, ssd_col], na.rm =TRUE)
  nthrt <- df1[,rt_col][nthindex]
  ssrt_raw <- nthrt - meanssd

  if(isTRUE(ssrt_raw <= 0)){
    ssrt = NA
  } else {
    ssrt = ssrt_raw
  }
  return(ssrt)
}


```





